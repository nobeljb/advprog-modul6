# Refleksi Modul 6

Berikut adalah refleksi untuk Milestone 1 sampai 5 yang telah dicapai dalam pengembangan server web sederhana menggunakan Rust:

**Commit 1: Refleksi**  
Function `handle_connection` dalam `main.rs` memiliki peran untuk mencetak permintaan HTTP mentah yang diterima server. Function ini menerima parameter berupa `TcpStream` yang kemudian diubah menjadi referensi untuk `BufReader`. Dengan menggunakan `BufReader`, permintaan HTTP diproses dengan memisahkan tiap baris berdasarkan karakter newline atau CRLF. Hasil pemrosesan ini menggunakan `unwrap()` karena method `lines()` mengembalikan struktur `Result<String, Error>`. Selanjutnya, isi permintaan diiterasi hingga ditemukan baris kosong, dengan hasil parsing yang disimpan dalam bentuk `Vector`, memungkinkan fleksibilitas dalam panjang datanya. Setelah itu, isi permintaan dicetak ke layar.

**Commit 2: Refleksi**  
Modifikasi pada function `handle_connection` kini memungkinkan server untuk mengirimkan respons HTTP sederhana dengan status `200 OK`. Respons tersebut dilengkapi dengan data HTML, sehingga ketika permintaan berasal dari browser, pengguna dapat melihat hasilnya secara langsung. Untuk memastikan browser dapat memproses respon dengan benar, header `Content-Length` ditambahkan, yang berfungsi menunjukkan panjang body dalam HTTP Response. Implementasi ini memungkinkan pengguna melihat tampilan halaman yang disediakan oleh server langsung dari browser.

**Commit 3: Refleksi**  
Peningkatan lebih lanjut pada function `handle_connection` memungkinkan server merespons berdasarkan URI yang diminta. Jika permintaan yang diterima merupakan GET Request ke `/` dengan versi `HTTP/1.1`, server mengirimkan konten dari `hello.html`. Sebaliknya, untuk permintaan yang tidak sesuai dengan pola tersebut, server mengembalikan `404.html`. Proses penentuan ini dilakukan dengan mengevaluasi baris pertama dari request yang diterima. Implementasi ini menyerupai konsep routing sederhana, di mana server merespons berdasarkan URI yang diminta. Pada awalnya, kode yang dibuat memiliki duplikasi dalam proses penentuan file HTML yang dikembalikan, sehingga dilakukan refactoring dengan cara mengekstrak `status_line` serta nama file HTML ke dalam variabel sebelum dikirim sebagai respons.

**Commit 4: Refleksi**  
Perubahan terbaru memungkinkan server menangani permintaan GET ke `/sleep`. Namun, implementasi ini menyebabkan semua permintaan lain harus menunggu hingga request ke `/sleep` selesai diproses, karena server berjalan secara single-threaded. Ketika ada permintaan ke `/sleep`, function `handle_connection` akan melakukan `sleep` selama 10 detik sebelum memberikan respons HTML, yang menyebabkan permintaan lain tertunda. Hal ini menunjukkan keterbatasan dalam pemrosesan single-threaded, terutama jika terdapat banyak permintaan ke `/sleep`, karena server hanya bisa menangani satu request dalam satu waktu, sehingga pengalaman pengguna menjadi kurang optimal.

**Commit 5: Refleksi**  
Untuk mengatasi permasalahan single-threaded, function `handle_connection` kini menggunakan `ThreadPool`. Struktur `ThreadPool` terdiri dari beberapa `Worker` dan `Sender` yang bertanggung jawab dalam mengeksekusi permintaan secara paralel. `Sender` dalam `ThreadPool` berfungsi mengirimkan pekerjaan (`Job`) ke `Worker`. Setiap `Worker` memiliki `Receiver`, yang disinkronkan menggunakan `Arc` dan `Mutex`, sehingga hanya satu `Worker` yang bisa mengaksesnya dalam satu waktu. Ketika sebuah `Worker` menerima tugas, ia akan mengunci thread hingga tugas selesai dieksekusi. Setelah selesai, thread kembali tersedia untuk menangani permintaan lain. Dengan adanya `ThreadPool`, server kini mampu menangani beberapa permintaan secara simultan, sehingga meskipun ada request yang membutuhkan waktu lama, permintaan lain tetap dapat diproses tanpa harus menunggu antrian yang panjang.

**Commit Bonus: Refleksi**  
Perbedaan utama antara function `build` dan function `new` pada `ThreadPool` terletak pada cara penanganan error. Function `build` menggunakan pendekatan yang lebih aman dengan mengembalikan `Result<ThreadPool, PoolCreationError>`. Dengan demikian, jika terjadi kesalahan saat pembuatan `ThreadPool`, error dapat ditangani tanpa harus menghentikan program. Sebaliknya, function `new` langsung mengembalikan objek `ThreadPool` tanpa mekanisme error handling yang baik, yang berarti jika ada kesalahan, program akan mengalami `panic` dan harus dijalankan ulang setelah error diperbaiki. Pendekatan `build` memberikan fleksibilitas dalam menangani error secara lebih terkontrol. 